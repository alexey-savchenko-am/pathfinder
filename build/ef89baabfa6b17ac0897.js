export function VectorMap(){this._vectors={}}VectorMap.prototype={get:function(t){return this._vectors[t.getString]},add:function(t,o){this._vectors[t.getString]=o},remove:function(t){const o=t.getString;this.contains(o)&&delete this._vectors[o]},contains:function(t){const o=t.getString;return this._vectors.hasOwnProperty(o)},forEach:function(t){for(const o in this._vectors)this._vectors.hasOwnProperty(o)&&t(this._vectors[o])}};export function Vector2D(t,o){this._row=t,this._col=o}Vector2D.prototype={get getRow(){return this._row},get getCol(){return this._col},get getString(){return`(${this._row};${this._col})`},hashCode:function(){return`${this._row}-${this._col}`},equalsTo:function(t){return t.getRow===this._row&&t.getCol===this._col},clone:function(){return new Vector2D(this._row,this._col)},round:function(){return new Vector2D(Math.ceil(this._row),Math.ceil(this._col))},add:function(t){return new Vector2D(this._row+t.getRow,this._col+t.getCol)},sub:function(t){return new Vector2D(this._row-t.getRow,this._col-t.getCol)},distance:function(t){return Math.abs(this._row-t.getRow)+Math.abs(this._col-t.getCol)},intersect:function(t){return 0!==t.row*this._col-t._col*this._row},left:function(){return new Vector2D(Math.ceil(this._row),Math.ceil(this._col-1))},right:function(){return new Vector2D(Math.ceil(this._row),Math.ceil(this._col+1))},bottom:function(){return new Vector2D(Math.ceil(this._row+1),Math.ceil(this._col))},top:function(){return new Vector2D(Math.ceil(this._row-1),Math.ceil(this._col))},topLeft:function(){return new Vector2D(Math.ceil(this._row-1),Math.ceil(this._col-1))},topRight:function(){return new Vector2D(Math.ceil(this._row-1),Math.ceil(this._col+1))},bottomLeft:function(){return new Vector2D(Math.ceil(this._row+1),Math.ceil(this._col-1))},bottomRight:function(){return new Vector2D(Math.ceil(this._row+1),Math.ceil(this._col+1))}};